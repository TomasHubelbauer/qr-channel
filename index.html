<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>QR Channel</title>
    <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
    <script src="https://unpkg.com/qrcode-generator"></script>
    <style>
      #viewfinderVideo { display: none; }
      #viewfinderCanvas {
        height: 100%;
        left: 0;
        opacity: .1;
        position: fixed;
        top: 0;
        width: 100%;
      }
      #codeCanvas {
        height: 100%;
        left: 0;
        opacity: .9;
        position: fixed;
        top: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>QR Channel</h1>
    <video id="viewfinderVideo"></video>
    <canvas id="viewfinderCanvas"></canvas>
    <canvas id="codeCanvas"></canvas>
    <p id="messageP"></p>
    <script>
      const viewfinderVideo = document.querySelector('#viewfinderVideo');
      const viewfinderCanvas = document.querySelector('#viewfinderCanvas');
      const codeCanvas = document.querySelector('#codeCanvas');
      const messageP = document.querySelector('#messageP');
      
      void async function() {
        const mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        viewfinderVideo.srcObject = mediaStream;
        // Set this attribute (not class member) through JavaScript (not HTML) to make iOS Safari work
        viewfinderVideo.setAttribute('playsinline', true);
        // Play within the `getUserMedia` gesture, `autoplay` won't work
        await viewfinderVideo.play();
        
        // Keep a reference to the context to refresh upon video size change
        let context;
        requestAnimationFrame(function tick() {
          if (viewfinderVideo.readyState === viewfinderVideo.HAVE_ENOUGH_DATA) {
            if (viewfinderCanvas.width !== viewfinderVideo.videoWidth || viewfinderCanvas.height !== viewfinderVideo.videoHeight) {
              viewfinderCanvas.width = viewfinderVideo.videoWidth;
              viewfinderCanvas.height = viewfinderVideo.videoHeight;
              context = viewfinderCanvas.getContext('2d');
            }

            context.drawImage(viewfinderVideo, 0, 0, viewfinderVideo.videoWidth, viewfinderVideo.videoHeight);
            const imageData = context.getImageData(0, 0, viewfinderCanvas.width, viewfinderCanvasRena.height);
            const code = jsQR(imageData.data, imageData.width, imageData.height);
            if (code !== null) {
              messageP.textContent = code.data;
            }
          }

          requestAnimationFrame(tick);
        });
      }()
      
      const qr = qrcode(1, 'L');
      qr.addData('01234567890123456789', 'Numeric');
      qr.make();
      
      const { width, height } = codeCanvas.getBoundingClientRect();
      codeCanvas.width = width;
      codeCanvas.height = height;
      // TODO: Reuse context if dimensions haven't changed since last render
      const context = codeCanvas.getContext('2d');
      // TODO: Clear context
      
      const size = Math.min(codeCanvas.width, codeCanvas.height);
      const moduleCount = qr.getModuleCount();
      const cellSize = size / moduleCount;
      
      const x = width - size;
      const y = height - size;
      for (let cellX = 0; cellX < moduleCount; cellX++) {
        for (let cellY = 0; cellY < moduleCount; cellY++) {
          if (qr.isDark(cellX, cellY)) {
            context.fillRect(x + cellX * cellSize, y + cellY * cellSize, cellSize, cellSize);
          }
        }
      }
    </script>
  </body>
</html>
